/* Generated By:JJTree: Do not edit this line. ASTExp.java */

package com.dw.system.codedom.parser;

import java.io.*;
import java.util.*;

import com.dw.system.codedom.RunContext;
import com.dw.system.codedom.AbstractRunEnvironment;
import com.dw.system.codedom.IOperRunner;

public class ASTExp extends SimpleNode
{
	/**
	 * 表达式的计算类型
	 * @author Jason Zhu
	 *
	 */
	public static enum BooleanCalType
	{
		RETURN_BOOL,
		RETURN_SET,
	}
	
	public ASTExp(int id)
	{
		super(id);
	}

	public ASTExp(UQLTreeParser p, int id)
	{
		super(p, id);
	}

	@Override
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if (children != null)
		{
			for (int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode) children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}
	
	@Override
	public void compileNode(AbstractRunEnvironment env)
	{
		int cc = this.jjtGetNumChildren();
		
		if(cc>3)
		{
			compileByOperPriority(env);
			cc = 3;
		}
		
		if(cc==3)
		{//处理
			ASTOper op = (ASTOper)jjtGetChild(1);
			if(op.getOperStr().equals("."))
			{//后者为 对象内属性或方法，它要求左操作对象先处理，并把左操作对象作为属性或方法的子节点
				Node leftn = jjtGetChild(0);
				Node rightn = jjtGetChild(2);
				if(rightn instanceof ASTExpFunc)
				{
					ASTExpFunc fn = (ASTExpFunc)rightn;
					fn.setRunObjNode(leftn);
					
					this.replaceChildrenWithNewNode(0, 3, fn);
				}
				else if(rightn instanceof ASTExpProp)
				{
					ASTExpProp pn = (ASTExpProp)rightn;
					pn.setRunObjNode(leftn);
					
					this.replaceChildrenWithNewNode(0, 3, pn);
				}
				else
				{
					throw new RuntimeException(". oper must be func exp or prop exp!");
				}
			}
		}
		
		cc = this.jjtGetNumChildren();
		//如果只有一个子节点，则在Dom树中删除自己
		if(cc==1&&this.parent!=null)
		{
			replaceMeWithSingleChild();
		}
	}
	
	
	/**
	 //如果内部有多个操作符，则根据优先级做树节点重构
		//如：parse-->user.id=3 or role.id=8 and to_int(@v)+8=9
+[0]Exp(child_num=17)
|--[1]Var:user
|--[1]Oper:.
|--[1]ExpProp:id
|--[1]Oper:=
|--[1]Const:3
|--[1]Oper:or
|--[1]Var:role
|--[1]Oper:.
|--[1]ExpProp:id
|--[1]Oper:=
|--[1]Const:8
|--[1]Oper:and
|--+ExpFunc:to_int
|--|--+[2]ArgumentList
|--|--|--+[3]Exp(child_num=1)
|--|--|--|--[4]Var:@v
|--[1]Oper:+
|--[1]Const:8
|--[1]Oper:=
|--[1]Const:9
		//---构造如下

+[0]Exp(child_num=3)
|--+[1]Exp(child_num=3)
|--|--+[2]Exp(child_num=3)
|--|--|--[3]Var:user
|--|--|--[3]Oper:.
|--|--|--[3]ExpProp:id
|--|--[2]Oper:=
|--|--[2]Const:3
|--[1]Oper:or
|--+[1]Exp(child_num=3)
|--|--+[2]Exp(child_num=3)
|--|--|--+[3]Exp(child_num=3)
|--|--|--|--[4]Var:role
|--|--|--|--[4]Oper:.
|--|--|--|--[4]ExpProp:id
|--|--|--[3]Oper:=
|--|--|--[3]Const:8
|--|--[2]Oper:and
|--|--+[2]Exp(child_num=3)
|--|--|--+[3]Exp(child_num=3)
|--|--|--|--+ExpFunc:to_int
|--|--|--|--|--+[5]ArgumentList
|--|--|--|--|--|--[6]Var:@v
|--|--|--|--[4]Oper:+
|--|--|--|--[4]Const:8
|--|--|--[3]Oper:=
|--|--|--[3]Const:9
		//算法思路：
		//1,从左往右扫描每个Oper，找到优先级最大的值和相关oper位置
		//2，按顺序对上面的oper位置进行Exp组合，每次组合后，递减操作数值，如果＝1，则结束
		//3，重复1，2过程，直到操作数变为1
	 */
	private void compileByOperPriority(AbstractRunEnvironment env)
	{
		int cc = this.jjtGetNumChildren();
		if(cc<=3)
			return ;
		
		int oper_num = cc / 2 ;
		List<Integer> priVals = new ArrayList<Integer>() ;
		
		for(int i = 0 ; i < oper_num ; i ++)
		{//循环找出所有的操作数优先级值
			int v = ((ASTOper)this.jjtGetChild(i*2+1)).getOperPriority();
			if(!priVals.contains(v))
				priVals.add(v);
		}
		
		//排序
		Integer[] privs = new Integer[priVals.size()];
		priVals.toArray(privs);
		Arrays.sort(privs);
		
		for(int p = privs.length-1 ; p >=0 ; )
		{
			int curpri = privs[p];
			//找到当前最大优先级oper第一次出现的位置
			int pri_first_pos = -1 ;
			for(int i = 0 ; i < oper_num ; i ++)
			{
				int pri_i = ((ASTOper)this.jjtGetChild(i*2+1)).getOperPriority();
				if(pri_i==curpri)
				{
					pri_first_pos = i ;
					break ;
				}
			}
			
			if(pri_first_pos<0)
			{
				p --;
				continue ;//当前优先级已经处理完毕，处理下一个优先级
			}
			
			int p0 = pri_first_pos*2+1 ;
			SimpleNode leftn = (SimpleNode)this.jjtGetChild(p0-1);
			SimpleNode opn = (SimpleNode)this.jjtGetChild(p0);
			SimpleNode rightn = (SimpleNode)this.jjtGetChild(p0+1);
			ASTExp newnode = new ASTExp(this.parser,UQLTreeParserTreeConstants.JJTEXP);
			newnode.addChild(leftn,0);
			newnode.addChild(opn,1);
			newnode.addChild(rightn,2);
			
			replaceChildrenWithNewNode(p0-1,3,newnode);
			
			newnode.compileNode(env);
			
			oper_num -- ;
			
			if(oper_num<=1)
				break;
		}
	}
	
	@Override
	public String toString()
	{
		return super.toString()+"(child_num="+this.jjtGetNumChildren()+")";
	}
	
	public Object runGetValue(AbstractRunEnvironment env,RunContext context)
		throws Exception
	{
		int cc = this.jjtGetNumChildren() ;
		
		if(cc==1)
		{
			return this.jjtGetChild(0).runGetValue(env, context);
		}
		
		if(cc==3)
		{//三元操作
			ASTOper opnode = (ASTOper)this.jjtGetChild(1);
			IOperRunner oper = opnode.getOperRunner();
			if(oper==null)
				throw new Exception("cannot get oper runner with oper="+opnode.getOperStr()+",may be not be compiled!");
			
			Node leftdn = this.jjtGetChild(0);
			Node rightdn = this.jjtGetChild(2);
			Object leftv = leftdn.runGetValue(env, context);
			Object rightv = rightdn.runGetValue(env, context);
			
			return oper.calculate(env, context, leftdn, rightdn, leftv, rightv);
		}
		
		throw new RuntimeException("Invalid Exp Node");
	}
}
