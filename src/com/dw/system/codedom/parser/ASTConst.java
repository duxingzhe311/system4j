/* Generated By:JJTree: Do not edit this line. ASTConst.java */

package com.dw.system.codedom.parser;

import java.io.*;
import java.lang.*;
import java.util.*;

import java.text.SimpleDateFormat;

import com.dw.system.codedom.RunContext;
import com.dw.system.codedom.AbstractRunEnvironment;

public class ASTConst extends SimpleNode
{
	public enum LiteralType
	{
		UNKNOWN(0), NULL(1), INTEGER(2), FLOAT(3), STR(4), BOOL(5), CHAR(6);

		private final int val;

		LiteralType(int v)
		{
			val = v;
		}
	}

	public enum ValType
	{
		UNKNOWN(0), NULL(1), BYTE(2), INT16(3), INT32(4), INT64(5), FLOAT(6), DOUBLE(
				7),

		STR(8),

		BOOL(9),

		CHAR(10);

		private final int val;

		ValType(int v)
		{
			val = v;
		}

		public int getTypeIntValue()
		{
			return val;
		}
	}

	public static ValType getNumberValueType(Object o)
	{
		if (o == null)
			throw new IllegalArgumentException("object is null");

		if (o instanceof Byte)
			return ValType.BYTE;

		if (o instanceof Short)
			return ValType.INT16;

		if (o instanceof Integer)
			return ValType.INT32;

		if (o instanceof Long)
			return ValType.INT64;

		if (o instanceof Float)
			return ValType.FLOAT;

		if (o instanceof Double)
			return ValType.DOUBLE;

		throw new IllegalArgumentException("object is not number Val type");
	}

	public static ValType getNumberCalReturnValueType(Object o1, Object o2)
	{
		// BYTE(2),INT16(3),INT32(4),FLOAT(5),INT64(6),DOUBLE(7),
		ValType vt1 = getNumberValueType(o1);
		ValType vt2 = getNumberValueType(o2);

		if ((vt1 == ValType.INT64 && vt2 == ValType.FLOAT)
				|| (vt2 == ValType.INT64 && vt1 == ValType.FLOAT))
		{
			return ValType.DOUBLE;
		}

		// 其他情况比较值大小即可
		int vtv1 = vt1.getTypeIntValue();
		int vtv2 = vt2.getTypeIntValue();

		return vtv1 > vtv2 ? vt1 : vt2;
	}

	private static Object literalStr2Obj(LiteralType type, String xmlestr,
			ValType[] outvt)
	{
		switch (type)
		{
		case NULL:
			outvt[0] = ValType.NULL;
			return null;
		case BOOL:
			outvt[0] = ValType.BOOL;
			return new Boolean("true".equals(xmlestr));
		case STR:
			outvt[0] = ValType.STR;
			return literalStr2ValStr(xmlestr);
		case INTEGER:
			xmlestr = xmlestr.toLowerCase();
			if (xmlestr.endsWith("l"))
			{
				xmlestr = xmlestr.substring(0, xmlestr.length() - 1);
				outvt[0] = ValType.INT64;
				if (xmlestr.startsWith("0x"))
					return Long.parseLong(xmlestr.substring(2), 16);
				else if (xmlestr.startsWith("0o")) // 8进制表示和java不一样，需要0o
					return Long.parseLong(xmlestr.substring(2), 8);
				else if (xmlestr.startsWith("0b")) // 2进制表示和java不一样，需要0b
					return Long.parseLong(xmlestr.substring(2), 2);
				else
					return Long.parseLong(xmlestr);
			}
			else if (xmlestr.endsWith("s"))
			{
				xmlestr = xmlestr.substring(0, xmlestr.length() - 1);
				outvt[0] = ValType.INT16;
				if (xmlestr.startsWith("0x"))
					return Short.parseShort(xmlestr.substring(2), 16);
				else if (xmlestr.startsWith("0o")) // 8进制表示和java不一样，需要0o
					return Short.parseShort(xmlestr.substring(2), 8);
				else if (xmlestr.startsWith("0b")) // 2进制表示和java不一样，需要0b
					return Short.parseShort(xmlestr.substring(2), 2);
				else
					return Short.parseShort(xmlestr);
			}
			else
			{
				outvt[0] = ValType.INT32;
				if (xmlestr.startsWith("0x"))
					return Integer.parseInt(xmlestr.substring(2), 16);
				else if (xmlestr.startsWith("0o")) // 8进制表示和java不一样，需要0o
					return Integer.parseInt(xmlestr.substring(2), 8);
				else if (xmlestr.startsWith("0b")) // 2进制表示和java不一样，需要0b
					return Integer.parseInt(xmlestr.substring(2), 2);
				else
					return Integer.parseInt(xmlestr);
			}
		case FLOAT:
			xmlestr = xmlestr.toLowerCase();
			if (xmlestr.endsWith("f"))
			{
				outvt[0] = ValType.FLOAT;
				return Float.parseFloat(xmlestr);
			}
			else
			{
				outvt[0] = ValType.DOUBLE;
				return Double.parseDouble(xmlestr);
			}
		case CHAR:
			outvt[0] = ValType.CHAR;
			return literalStr2ValChar(xmlestr);
		default:
			throw new RuntimeException("unknow type=" + type);
		}
	}

	private static String literalStr2ValStr(String str)
	{
		if (str.startsWith("\""))
			str = str.substring(1);
		if (str.endsWith("\""))
			str = str.substring(0, str.length() - 1);

		// 对字符串内部的各种表示方式进行解码
		if (str == null || str.equals(""))
			return str;

		StringBuffer tmpsb = new StringBuffer();

		int p = 0;
		while (p < str.length())
		{
			char c = str.charAt(p);
			if (c != '\\')
			{
				tmpsb.append(c);
				p++;
			}
			else
			{
				char tmpc = str.charAt(p + 1);
				if (tmpc == 'u')
				{// \u00ff
					char c1 = decodeStrToChar(str.substring(p, p + 6));
					tmpsb.append(c1);
					p = p + 6;
				}
				else if (tmpc >= '0' && tmpc <= '3')
				{// \211
					char c1 = decodeStrToChar(str.substring(p, p + 4));
					tmpsb.append(c1);
					p = p + 4;
				}
				else
				{// \r
					char c1 = decodeStrToChar(str.substring(p, p + 2));
					tmpsb.append(c1);
					p = p + 2;
				}
			}
		}

		return tmpsb.toString();
	}

	private static char literalStr2ValChar(String str)
	{
		if (str.startsWith("\'"))
			str = str.substring(1);
		if (str.endsWith("\'"))
			str = str.substring(0, str.length() - 1);

		if (str.length() == 1)
			return str.charAt(0);

		return decodeStrToChar(str);
	}

	private static char decodeStrToChar(String str)
	{
		if (str.length() == 1)
			return str.charAt(0);

		if (str.charAt(0) != '\\')
		{
			throw new RuntimeException("invalid char " + str);
		}

		switch (str.charAt(1))
		{
		case 'b':
			return '\b';
		case 't':
			return '\t';
		case 'n':
			return '\n';
		case 'f':
			return '\f';
		case 'r':
			return '\r';
		case '\"':
			return '\"';
		case '\'':
			return '\'';
		case '\\':
			return '\\';
		case 'u': // \u00ff
			return (char) Integer.parseInt(str.substring(2), 16);
		default: // \123
			char c = str.charAt(1);
			if (c >= '0' && c <= '3' && str.length() == 4)
				return (char) Integer.parseInt(str.substring(1));
			else
				throw new RuntimeException("invalid char str=" + str);
		}
	}

	LiteralType literalType = LiteralType.UNKNOWN;

	String literalVal = null;

	transient Object constVal = null;

	transient ValType valType = ValType.UNKNOWN;

	public ASTConst(int id)
	{
		super(id);
	}

	public ASTConst(UQLTreeParser p, int id)
	{
		super(p, id);
	}

	public String getLiteralValue()
	{
		return literalVal;
	}

	public LiteralType getLiteralType()
	{
		return literalType;
	}

	public void setLiteralValue(LiteralType type, String strv)
	{
		literalType = type;
		literalVal = strv;
	}

	public ValType getValType()
	{
		return valType;
	}

	public Object getConstValue()
	{
		return constVal;
	}

	/**
	 * 得到对应的Java类，以便于支持更多语法树的操作，如：编译中的语义判断等。
	 * 
	 * @return
	 */
	public Class getValJavaClass()
	{
		switch (valType)
		{
		case NULL:
			return null;
		case DOUBLE:
			return Double.class;
		case FLOAT:
			return Float.class;
		case INT64:
			return Long.class;
		case INT32:
			return Integer.class;
		case INT16:
			return Short.class;
		case BYTE:
			return Byte.class;
		case STR:
			return String.class;
		case BOOL:
			return Boolean.class;
		case CHAR:
			return Character.class;
		default:
			throw new RuntimeException(
					"Unknow const type,may be it not be compiled!");
		}
	}

	@Override
	public String toString()
	{
		return super.toString() + ":Literal->" + literalType + "=" + literalVal
				+ " Value->" + valType + "=" + constVal;
	}

	/**
	 * 重载该方法使编译后，节点内的常直接生成对应的对象
	 */
	@Override
	public void compileNode(AbstractRunEnvironment env)
	{
		ValType[] vts = new ValType[1];
		constVal = literalStr2Obj(literalType, literalVal, vts);
		valType = vts[0];
	}

	public Object runGetValue(AbstractRunEnvironment env,
			RunContext context) throws Exception
	{
		if (valType == ValType.UNKNOWN)
			throw new Exception(
					"invalid const type,may be it is not be compiled");

		return constVal;
	}
}
