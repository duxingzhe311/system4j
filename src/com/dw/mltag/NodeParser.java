package com.dw.mltag;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Vector;

import com.dw.system.Convert;

/**
 * This class will read HTML data(typically generated by <b>MS Word</b> 2000
 * V9.0) from <code>InputStream</code> and convert into <code>valid XML</code>
 * document. <br/> Because HTML have some simple-write properties such as the
 * following: Empty tag without terminator.<br/> Short attribute value have no
 * <code>&quot;</code> identify.<br/> Long attribute value using
 * <code>'</code> identify.<br/> More style tag(attribute) defined.<br/>
 * <br/> A DOM level parser, a XML-Tree will be bulit after parsing completed.<br/>
 * No handler supported.<br/> <br/> Changes : <br/> No ignored Element
 * implementation.<br/> No ignored Attribute implementation.<br/> Internal
 * entities not support nbsp.<br/> validate () to parse ().<br/> Support empty
 * attribute, such as <b>&lt;option selected&gt;</b>, will be convert into
 * <b>&lt;option selected=""&gt;</b>.<br/> Support JSP Tag and Jsp
 * Comment(include '&lt;% %&gt;' &amp; '&lt;%-- --%&gt;'). Support JSP Page Tag
 * ('&lt;%@ page ... %&gt;' only). Bug Fixed: blanks within element declaration
 * will be append as a child of the element. Bug Fixed: attribute value which
 * contains a '/' and have no qout, e.g. value=a/b/c.html. Bug Fixed: Ignore
 * Non-naming-char.
 */

public class NodeParser
{
	// private Writer out ;
	// // private OutputStreamWriter frame ;

	private static String XML_HEAD = "<?xml version = \"1.0\" encoding = \"GBK\"?>";

	private static String XML_DOCTYPE = "<!DOCTYPE root [<!ENTITY nbsp \"&#160;\">]>";

	protected static String INTERNAL_ENTITIES = "|lt|gt|quot|amp|nbsp|";

	protected int ch = -1;

	protected static String NL = System.getProperty("line.separator");

	public static boolean isHtmlNoChildElement(String elename)
	{
		return AbstractNode.NO_CHILD_ELEMENTS.indexOf("|" + elename + "|") >= 0;
	}

	protected PushbackReader in;

	protected boolean ignoreCase = false;

	protected XmlNode root = null;

	protected AbstractNode currentNode = root;

	protected boolean isInELementDecl = false;

	protected TagDocument tagDoc = null;

	public static boolean IS_FOR_HTML = true;
	
	protected KeyNode keyNodeRoot = null ;

	protected KeyNode currentKeyNode = null ;

	/**
	 * Using I/O stream as parameters.
	 */
	public NodeParser(InputStream in) throws IOException
	{
		this(in, null);
	}

	public NodeParser(InputStream in, TagDocument doc) throws IOException
	{
		this(in, doc, "GBK");
	}

	public NodeParser(InputStream in, TagDocument doc, String encoding)
			throws IOException
	{
		if(Convert.isNullOrEmpty(encoding))
		{
			encoding = System.getProperty("file.encoding") ;
		}
		this.in = new PushbackReader(new InputStreamReader(in, encoding), 5);
		tagDoc = doc;
	}

	public NodeParser(Reader in) throws IOException
	{
		this(in, null);
	}

	public NodeParser(Reader in, TagDocument doc) throws IOException
	{
		this.in = new PushbackReader(in, 5);
		tagDoc = doc;
	}

	/**
	 * Open file as I/O stream.
	 * 
	 * @exception IOException
	 *                if exception occurs during file operation.
	 */
	public NodeParser(String inFile) throws IOException
	{
		in = new PushbackReader(new InputStreamReader(new FileInputStream(
				inFile), "GBK"), 5);
	}

	/**
	 * For HTML convert element name and attribute name into lowcase. if setted
	 * is true.
	 */
	public void setIgnoreCase(boolean bol)
	{
		ignoreCase = bol;
	}

	/**
	 * Return the state.
	 */
	public boolean isIgnoreCase()
	{
		return ignoreCase;
	}

	/*
	 * public void addIgnoredElement (String name) { if (name == null ||
	 * name.length () == 0) return ;
	 * 
	 * if (NO_USED_ELEMENTS == null || NO_USED_ELEMENTS.length () == 0)
	 * NO_USED_ELEMENTS = "|" + name + "|" ; else NO_USED_ELEMENTS += name + "|" ; }
	 * 
	 * public void removeIgnoredElement (String name) { if (name == null ||
	 * name.length () == 0) return ;
	 * 
	 * int index = NO_USED_ELEMENTS.indexOf ("|" + name + "|") ; if (index >= 0)
	 * NO_USED_ELEMENTS = NO_USED_ELEMENTS.suString (0 , index) +
	 * NO_USED_ELEMENTS.subString (index + name.length () + 1) ;
	 *  } public void addIgnoredAttr (String name) { if (name == null ||
	 * name.length () == 0) return ;
	 * 
	 * if (NO_USED_ELEMENTS == null || NO_USED_ELEMENTS.length () == 0)
	 * NO_USED_ELEMENTS = "|" + name + "|" ; else NO_USED_ELEMENTS += name + "|" ; }
	 * 
	 * public void removeIgnoredElement (String name) { if (name == null ||
	 * name.length () == 0) return ;
	 * 
	 * int index = NO_USED_ELEMENTS.indexOf ("|" + name + "|") ; if (index >= 0)
	 * NO_USED_ELEMENTS = NO_USED_ELEMENTS.suString (0 , index) +
	 * NO_USED_ELEMENTS.subString (index + name.length () + 1) ;
	 *  }
	 */
	/**
	 * When parseing completed, this method should be call to recive the result.
	 */
	public XmlNode getRoot()
	{
		return root;
	}

	private XmlNode parseCreateXmlNode(String name, Attr[] attrs)
	{
		if (tagDoc == null)
		{
			XmlNode xn = new XmlNode(name);
			xn.setAttributes(attrs);
			return xn;
		}
		else
		{
			try
			{
				if (tagDoc.isIgnoreCase())
					name = name.toLowerCase();

				return tagDoc.createXmlNode(name, attrs);
			}
			catch (Throwable t)
			{
				t.printStackTrace();
				XmlNode xn = new XmlNode(name, t);
				xn.setAttributes(attrs);
				return xn;
			}
		}
	}

	private XmlText parseCreateXmlText(String text)
	{
		if (tagDoc == null)
			return XmlText.parseToXmlText(text);
		else
			return tagDoc.createXmlText(text);
	}

	private XmlComment parseCreateXmlComment(String cmt)
	{
		if (tagDoc == null)
			return new XmlComment(cmt);
		else
			return tagDoc.createXmlComment(cmt);
	}
	
	private ScriptComment parseCreateScriptComment(String cmt)
	{
		if (tagDoc == null)
			return new ScriptComment(cmt);
		else
			return tagDoc.createScriptComment(cmt);
	}

	private JspDirective parseCreateJspPageTag(String jspdir_t)
	{
		if (tagDoc == null)
			return new JspDirective(jspdir_t);
		else
			return tagDoc.createJspPageTagNode(jspdir_t);

	}

	private JspTag parseCreateJspTag(String txt)
	{
		if (tagDoc == null)
			return new JspTag(txt);
		else
			return tagDoc.createJspTagNode(txt);
	}

	private JspDeclaration parseCreateJspDeclaration(String txt)
	{
		if (tagDoc == null)
			return new JspDeclaration(txt);
		else
			return tagDoc.createJspDeclaration(txt);
	}
	
	private JspExpression parseCreateJspExpression(String txt)
	{
		if (tagDoc == null)
			return new JspExpression(txt);
		else
			return tagDoc.createJspExpression(txt);
	}

	private JspComment parseCreateJspComment(String cmt)
	{
		if (tagDoc == null)
			return new JspComment(cmt);
		else
			return tagDoc.createJspCommentNode(cmt);
	}

	private XmlDeclNode parseCreateXmlDeclNode(String txt)
	{
		if (tagDoc == null)
			return new XmlDeclNode(txt);
		else
			return tagDoc.createXmlDeclNode(txt);
	}

	public void parse() throws IOException
	{
		parse(null);
	}

	/**
	 * Do XML file parsing.<br/> If encounter '&lt', will call
	 * {@link #maybeElementDecl()}; otherwise call {@link #maybePCData()}.
	 * 
	 */
	public void parse(PushbackReader reader) throws IOException
	{
		if (reader != null)
			in = reader;

		isInELementDecl = false;

		root = parseCreateXmlNode("root", null);

		currentNode = root;

		ch = in.read();
		peek();
		while (ch != -1)
		{
			if (ch == '<')
			{
				maybeElementDecl();
				ch = in.read();
				// System.out.println ("ElementDecl end: [" + (char) ch + "]") ;
			}
			else
				maybePCData();

			peek();
		}

	}

	/**
	 * Proceed <code>PCDATA</code>(text).<br/> If encounter a '&amp;', will
	 * call {@link #maybeEntity()}; otherwise write out it.
	 */
	protected void maybePCData() throws IOException
	{
		String text = "";
		while (ch != -1 && ch != '<')
		{
			/*
			 * // disable Entity Escaping. if (ch == '&') { text += maybeEntity () ; }
			 */
			/*
			 * reserv whiteSpace. else if (isDelimiter (ch)) { text += ' ' ;
			 * peek () ; continue ; }
			 */
			// else
			text += (char) ch;
			// out.write (ch) ;

			ch = in.read();
		}
		// System.out.println ("[" + text + "]") ;
		if (!text.equals(""))
		{
			if (root == null)
			{
				throw new IOException("Must have a root Node! ");
				// root = XmlText.parseToXmlText(text) ;
			}
			else
			{
				// System.out.println ("currentNode:" + currentNode) ;
				currentNode.addChild(parseCreateXmlText(text));
				// System.out.println ("currentNode:" + currentNode) ;
			}
		}
	}

	/**
	 * Get entity's name and check it as supported entities.<br/> ENTITY:
	 * &amp;entityname;
	 */
	protected String maybeEntity() throws IOException
	{
		ch = in.read();

		String name = "";

		while (ch != ';' || (ch >= 'a' && ch <= 'z')
				|| (ch >= 'A' && ch <= 'Z'))
		{
			name += (char) ch;
			ch = in.read();
		}

		// System.out.println ("Entity name = " + name) ;
		if (ch != ';') // invalid entity reference
			return "";
		name = name.toLowerCase();

		if (INTERNAL_ENTITIES.indexOf("|" + name + "|") >= 0)
			return "&" + name + ";";
		else
			return "";
	}

	protected void maybeElementDecl()throws IOException
	{
		ch = in.read () ;

		if (ch == -1)
			return ;

		if (ch == '!')
		{
			maybeComment () ;

			// ch = in.read () ;
			return ;
		}

		if (ch == '%')
		{
			maybeJspTag () ;
			return ;
		}

		if (ch == '?')
		{
			maybePI () ;
			// ch = in.read () ;
			return ;
		}

		isInELementDecl = true ;

		peek () ;

		if (ch == '/')
		{
			maybeElementEnd () ;

			isInELementDecl = false ;
			// ch = in.read () ;
			return ;
		}
		String name = "" ;

		// get name
		while (!isDelimiter (ch) && ch != '>' && ch != '/')
		{
			name += (char) ch ;
			ch = in.read () ;
		}

		if (ignoreCase)
			name = name.toLowerCase () ;


		ArrayList<Attr> attrlist = new ArrayList<Attr>() ;
		//分析一个元素节点名称之后的内容
		while (ch != -1)
		{
			peek () ;

			if (ch == '>' || ch == '/')
				break ;
			Attr attr = maybeAttr () ;

			// if (checkAttribute (name , attr))
			//			Console.WriteLine (" " + attr.Name+ "=\"" + attr.Value + "\"") ;

			if (attr != null)
				attrlist.add(attr) ;
		}

		XmlNode tmpnode = null ;

		int nodestyle ;
		if (ch == '/')
		{//发现没有子节点的元素
			ch = in.read () ;
			while (ch != '>' && ch != -1)
				ch = in.read () ;

			if(IS_FOR_HTML&&AbstractNode.NEED_CHILD_ELEMENTS.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_NEED_CHILD;
			}
			else
			{
				nodestyle = AbstractNode.NODE_STYLE_NO_CHILD ;
			}

			tmpnode = new XmlNode (name , currentNode) ;
		}
		else
		{//
			//			if(AbstractNode.IS_FOR_HTML&&!HTML_TAGS.IsHtmlTag(name))
			//			{//忽略该标签，但会继续扫描其子节点
			//				
			//			}


			if (IS_FOR_HTML&&AbstractNode.NO_CHILD_ELEMENTS.indexOf ("|" + name.toLowerCase () + "|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_NO_CHILD ;

				tmpnode = new XmlNode (name , currentNode) ;
			}
			else if(IS_FOR_HTML&&AbstractNode.META_HTML_ELEMENT.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_META;

				tmpnode = new XmlNode (name , currentNode) ;
			}
			else if(IS_FOR_HTML&&AbstractNode.KEY_HTML_ELEMENT.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_KEY;

				tmpnode = new KeyNode (name , currentNode) ;
			}
			else
			{
				nodestyle = AbstractNode.NODE_STYLE_NEED_CHILD;

				tmpnode = new XmlNode (name , currentNode) ;
			}

		}

		for(Attr att : attrlist)
		{
			tmpnode.setAttr(att) ;
		}

		if (currentNode == null || root == null)
		{
			root = tmpnode ;
			currentNode = tmpnode ;
		}
		else
		{
			currentNode.addChild (tmpnode) ;
		}
	

	
		//		if(name=="meta")
		//		{
		//			Console.WriteLine("Begin Element={0} NodeStyle={1}",name,nodestyle) ;
		//		}

    

		if(nodestyle==AbstractNode.NODE_STYLE_NEED_CHILD)
		{
			//有小孩的节点
			currentNode = tmpnode ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_META)
		{
			currentNode = tmpnode ;

			mayBeMetaHtmlElement(name) ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_KEY)
		{
			if(currentKeyNode==null||keyNodeRoot==null)
			{
				keyNodeRoot = (KeyNode)tmpnode ;
				currentKeyNode = (KeyNode)tmpnode ;
			}
			else
			{
				currentKeyNode.addKeyNodeChild((KeyNode)tmpnode) ;
			}

			//有小孩的节点
			currentNode = tmpnode ;
			currentKeyNode = (KeyNode)tmpnode ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_NO_CHILD)
		{
		}
		isInELementDecl = false ;
	}
	
	/**
	 * If encounter &quot;&lt;!&quot;, call{@link #maybeComment()};<br/> If
	 * &quot;&lt;%&quot;, call {@link #maybeJspTag()};<br/> If
	 * &quot;&lt;?&quot;, call {@link #maybePI()};<br/> If &quot;&lt;/&quot;,
	 * call {@link #maybeElementEnd()}</a>;<br/>
	 */
	protected void maybeElementDecl0() throws IOException
	{
		// System.out.println ("maybeElementDecl") ;
		ch = in.read();

		if (ch == -1)
			return;

		if (ch == '!')
		{
			maybeComment();

			// ch = in.read () ;
			return;
		}

		if (ch == '%')
		{
			maybeJspTag();
			return;
		}

		if (ch == '?')
		{
			maybePI();
			// ch = in.read () ;
			return;
		}

		isInELementDecl = true;

		peek();

		if (ch == '/')
		{
			maybeElementEnd();

			isInELementDecl = false;
			// ch = in.read () ;
			return;
		}
		String name = "";

		// get name
		while (!isDelimiter(ch) && ch != '>' && ch != '/')
		{
			name += (char) ch;
			ch = in.read();
		}

		if (ignoreCase)
			name = name.toLowerCase();

		/*
		 * if (! checkElement (name)) { ignoreElement () ;
		 * 
		 * return ; }
		 */
		// out.write ("<" + name) ;
		// XmlNode tmp = new XmlNode (name , currentNode) ;
		Vector attrvs = new Vector();
		while (ch != -1)
		{
			peek();

			if (ch == '>' || ch == '/')
				break;
			Attr attr = maybeAttr();

			// if (checkAttribute (name , attr))
			// out.write (" " + attr.getName () + "=\"" + attr.getValue () +
			// "\"") ;

			if (attr != null)
				// tmp.setAttribute (attr) ;
				attrvs.addElement(attr);
		}

		Attr[] attrs = new Attr[attrvs.size()];
		attrvs.toArray(attrs);
		
		XmlNode tmpnode = null;//this.parseCreateXmlNode(name, attrs);

		///////
		int nodestyle ;
		if (ch == '/')
		{//发现没有子节点的元素
			ch = in.read () ;
			while (ch != '>' && ch != -1)
				ch = in.read () ;

			if(IS_FOR_HTML&&AbstractNode.NEED_CHILD_ELEMENTS.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_NEED_CHILD;
			}
			else
			{
				nodestyle = AbstractNode.NODE_STYLE_NO_CHILD ;
			}

			tmpnode = new XmlNode (name , currentNode) ;
		}
		else
		{//
			//			if(AbstractNode.IS_FOR_HTML&&!HTML_TAGS.IsHtmlTag(name))
			//			{//忽略该标签，但会继续扫描其子节点
			//				
			//			}


			if (IS_FOR_HTML&&AbstractNode.NO_CHILD_ELEMENTS.indexOf ("|" + name.toLowerCase () + "|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_NO_CHILD ;

				tmpnode = new XmlNode (name , currentNode) ;
			}
			else if(IS_FOR_HTML&&AbstractNode.META_HTML_ELEMENT.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_META;

				tmpnode = new XmlNode (name , currentNode) ;
			}
			else if(IS_FOR_HTML&&AbstractNode.KEY_HTML_ELEMENT.indexOf("|"+name.toLowerCase()+"|")>=0)
			{
				nodestyle = AbstractNode.NODE_STYLE_KEY;

				tmpnode = new KeyNode (name , (AbstractNode)currentNode) ;
			}
			else
			{
				nodestyle = AbstractNode.NODE_STYLE_NEED_CHILD;

				tmpnode = new XmlNode (name , currentNode) ;
			}

		}
		
		for(Attr att : attrs)
		{
			tmpnode.setAttr(att) ;
		}
		
		if (currentNode == null || root == null)
		{
			root = tmpnode ;
			currentNode = tmpnode ;
		}
		else
		{
			currentNode.addChild (tmpnode) ;
		}
	

	
		//		if(name=="meta")
		//		{
		//			Console.WriteLine("Begin Element={0} NodeStyle={1}",name,nodestyle) ;
		//		}

    

		if(nodestyle==AbstractNode.NODE_STYLE_NEED_CHILD)
		{
			//有小孩的节点
			currentNode = tmpnode ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_META)
		{
			currentNode = tmpnode ;

			mayBeMetaHtmlElement(name) ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_KEY)
		{
			if(currentKeyNode==null||keyNodeRoot==null)
			{
				keyNodeRoot = (KeyNode)tmpnode ;
				currentKeyNode = (KeyNode)tmpnode ;
			}
			else
			{
				currentKeyNode.addKeyNodeChild((KeyNode)tmpnode) ;
			}

			//有小孩的节点
			currentNode = tmpnode ;
			currentKeyNode = (KeyNode)tmpnode ;
		}
		else if(nodestyle==AbstractNode.NODE_STYLE_NO_CHILD)
		{
		}
		isInELementDecl = false ;
		
		///////old code
		/*
		if (ch == '/')
		{
			ch = in.read();
			while (ch != '>' && ch != -1)
				ch = in.read();

			// out.write ("/>") ;

			// System.out.println ("Node [" + name + "]") ;
			if (currentNode == null || root == null)
			{
				root = tmp;
				currentNode = tmp;
			}
			else
				currentNode.addChild(tmp);
		}
		else
		{
			// System.out.println ("Node [" + name + "]" ) ;
			if (currentNode == null || root == null)
			{
				root = tmp;
				currentNode = tmp;

			}
			else
				currentNode.addChild(tmp);

			if (AbstractNode.NO_CHILD_ELEMENTS.indexOf("|"
					+ tmp.getNodeName().toLowerCase() + "|") < 0)
				currentNode = tmp;

		}
		isInELementDecl = false;
		*/
	}

	protected void mayBeMetaHtmlElement (String tagname) throws IOException
	{
		//Console.WriteLine("mayBeMetaHtmlElement") ;

		StringBuilder buf = new StringBuilder () ;
		while((ch = in.read ())>0)
		{
			if(ch!='<')
			{
				buf.append((char)ch) ;
			}
			else
			{
				StringBuilder notout = new StringBuilder();
				if(judgeMetaHtmlEndElement(tagname,notout))
				{
					//Console.WriteLine("script------"+buf.ToString ());
					//Console.ReadLine();
                    XmlText tmpxt = XmlText.parseToXmlText(buf.toString()) ;
                    	//XmlText.parseToXmlText(buf.toString(), IS_FOR_HTML, false);//new XmlText(buf.ToString()) ;
					currentNode.addChild(tmpxt) ;
					currentNode = (AbstractNode)currentNode.getParent() ;
					return ;
				}
				else
				{
					buf.append('<').append(notout) ;
				}
			}
		}

    
		currentNode.addChild (new XmlComment (buf.toString ())) ;
	}

	private boolean judgeMetaHtmlEndElement(String tagname,StringBuilder notoutput)
		throws IOException
	{
		//notoutput = "" ;
		//处理 </
		while((ch = in.read ())>0)
		{
			notoutput.append((char)ch) ;
			if(isDelimiter(ch))
			{
				continue ;
			}
			else if(ch!='/')
			{
				return false ;
			}
			else
			{//find </
				break ;
			}
		}

		//对比tagname
		String tmpn = "" ;
		while((ch = in.read ())>0)
		{
			notoutput.append((char)ch) ;
			if(isDelimiter(ch)||ch=='>')
			{
				break ;
			}

			tmpn+= (char)ch ;
		}

		if(ch!='>')
		{
			//处理 > 之前的空白字符
			while((ch = in.read ())>0)
			{
				notoutput.append((char)ch) ;
				if(isDelimiter(ch))
				{
					continue ;
				}
				else if(ch=='>')
				{
					break;
				}
				else
				{//find </
					//无效的结束元素
					return false ;
				}
			}
		}

		//对比tagname是否相等
		if(tmpn.equalsIgnoreCase(tagname))
			return true ;
		else
			return false ;
	}
	
	protected void maybeElementEnd () throws IOException
	{
		ch = in.read () ;

		peek () ;

		String name = "" ;

		while (! isDelimiter (ch) && ch != '>' && ch != -1)
		{
			name += (char) ch ;

			ch = in.read () ;
		}

		if (ignoreCase)
			name = name.toLowerCase () ;

		while (ch != '>' && ch != -1)
			ch = in.read () ;

		boolean iskey = false ;
		if(IS_FOR_HTML&&AbstractNode.KEY_HTML_ELEMENT.indexOf("|"+name.toLowerCase()+"|")>=0)
		{
			iskey = true ;
		}
		
		if(!name.equalsIgnoreCase(this.currentNode.getNodeName()))
		{
			if(iskey)
			{
				if(this.currentKeyNode.getNodeName().toLowerCase()!=name.toLowerCase())
					return ;

				currentNode = currentKeyNode ;

				if(currentKeyNode.getParentKeyNode()!=null)
					currentKeyNode = currentKeyNode.getParentKeyNode() ;
				//else
				//	Console.WriteLine("--1--key -end to root") ;




			
				return ;
			}

			//当前节点与发现的结束节点不匹配
			//处理如下:
			//1,查找当前节点的父结点,并进行匹配
			//2,建立一个元素标签重要程度表,比较如果发现自己没有
			//Console.WriteLine("**** End Element=</"+name+">   cur node="+currentNode.getNodeName()) ;
			return ;
		}

		//Console.WriteLine("End Element=</"+name+">") ;

		if(currentNode instanceof XmlNode)
		{
			((XmlNode)currentNode).bHasEndTag = true ;
		}

		if(currentNode.getParent()!=null)
			currentNode = (AbstractNode)currentNode.getParent() ;
		//else
		//	Console.WriteLine("--2---end to root") ;

		if(iskey)
		{
			if(currentKeyNode.getParentKeyNode()!=null)
				currentKeyNode = currentKeyNode.getParentKeyNode() ;
			//else
			//	Console.WriteLine("--2---end to root") ;
		}
	}
	
	/**
	 * A element ended.
	 */
	protected void maybeElementEnd0() throws IOException
	{
		// out.write ("</") ;

		ch = in.read();

		peek();

		String name = "";

		while (!isDelimiter(ch) && ch != '>' && ch != -1)
		{
			name += (char) ch;

			ch = in.read();
		}
		if (ignoreCase)
			name = name.toLowerCase();

		while (ch != '>' && ch != -1)
			ch = in.read();

		// if (checkElement (name))
		{
			//if(currentNode!=null)
			AbstractNode tmpn = (AbstractNode)currentNode.getParent() ;
			if(tmpn!=null)
				currentNode = tmpn;
		}

	}

	/**
	 * Comment will be ingored.
	 */
	protected void maybeComment() throws IOException
	{
		// System.out.println ("maybeComment") ;

		StringBuffer buf = new StringBuffer();
		ch = in.read();
		if (ch == '-')
		{
			ch = in.read();
			if (ch == '-')
			{
				// <--

				while ((ch = in.read()) != -1)
				{

					if (ch == '-')
					{
						if ((ch = in.read()) == '-')
						{
							if ((ch = in.read()) == '>')
								break;
							else
							{
								buf.append("--");
								buf.append((char) ch);
							}
						}
						else
						{
							buf.append('-');
							buf.append((char) ch);
						}
					}
					else
						buf.append((char) ch);
				}
			}

			//不支持注释中有<%%>的旧代码
			//XmlComment tmpcmt = parseCreateXmlComment(buf.toString());
			ScriptComment tmpsc = parseCreateScriptComment(buf.toString());
			currentNode.addChild(tmpsc);
		}
		else
			maybeDocDecl();

	}

	/**
	 * Gather a Jsp Tag, as a Comment.<br/> If encounter &quot;&lt;%--&quot;,
	 * call {@link #maybeJspComment()}.<br/> If encounter &quot;&lt;%@&quot;,
	 * call {@link #parseJspTag(java.lang.String)}.<br/>
	 * 
	 * @since 1.5
	 */
	protected void maybeJspTag() throws IOException
	{
		StringBuffer buf = new StringBuffer();
		ch = in.read();
		if (ch == '-')
		{
			ch = in.read();
			if (ch == '-')
			{
				// <%--
				maybeJspComment();
				return;
			}
			else
				buf.append('-');
		}
		do
		{
			if (ch == '%')
			{
				if ((ch = in.read()) == '>')
					break;

				buf.append("%");
				buf.append((char) ch);
			}
			else
				buf.append((char) ch);
		}
		while ((ch = in.read()) != -1);

		currentNode.addChild(parseJspTag(buf.toString()));
	}

	/**
	 * Try to parse JspPage Tag using following matching:<br/> &nbsp;<%@[space]page
	 * [name[space]="[value]"]%><br/>
	 * 
	 * @return {@link com.dw.mltag.JspDirective} or {@link com.dw.mltag.JspTag}
	 * @since 1.5.1
	 */
	protected Node parseJspTag(String text)
	{

		if (text == null)
			return null;
		if (text.length() <= 0)// || text.charAt (0) != '@')
			return new JspTag(text);

		if(text.charAt(0)=='!')
		{
			text = text.substring(1).trim();
			JspDeclaration jd = this.parseCreateJspDeclaration(text);
			return jd ;
		}
		
		if(text.charAt(0)=='=')
		{
			text = text.substring(1).trim();
			JspExpression jd = this.parseCreateJspExpression(text);
			return jd ;
		}
		
		if (text.charAt(0) == '@')
		{
			text = text.substring(1).trim();
			// System.out.println ("text [" + text + "]") ;

			JspDirective pTag = null;// new JspPageTag ()
															// ;
			// JspPageTag pTag = new JspPageTag () ;
			int k = text.indexOf(' ');
			if(k<=0)
				throw new RuntimeException("invalid directive jsp tag:"+text);

			String n = text.substring(0,k);
			text = text.substring(k+1);
			pTag = parseCreateJspPageTag(n);
			
//			if (text.toLowerCase().startsWith("page "))
//			{
//				text = text.substring(4);
//				pTag = this.parseCreateJspPageTag("page");
//			}
//			else if(text.toLowerCase().startsWith("include "))
//			{
//				text = text.substring(7);
//				pTag = this.parseCreateJspPageTag("include");
//			}
//			else if(text.toLowerCase().startsWith("taglib "))
//			{
//				text = text.substring(6);
//				pTag = this.parseCreateJspPageTag("taglib");
//			}
//			else
//			{
//				throw new RuntimeException("unknown JspDirective type!");
//			}
			
			int pos = 0;
			int index = -1;
			while ((index = text.indexOf('=', pos)) >= 0)
			{
				String attrName = text.substring(pos, index).trim();

				// System.out.println ("find attr: [" + attrName + "]") ;
				pos = index;

				index = text.indexOf('\"', pos);

				if (index < 0)
					break;

				pos = text.indexOf('\"', index + 1);

				if (pos < 0)
					pos = text.length() - 1;

				String attrValue = text.substring(index + 1, pos).trim();

				pTag.setAttribute(attrName, attrValue);
				pos ++ ;
			}
			
			return pTag ;
		}

		return new JspTag(text);
	}

	/**
	 * Deal with Jsp Comment.
	 */
	protected void maybeJspComment() throws IOException
	{
		StringBuffer buf = new StringBuffer();

		while ((ch = in.read()) != -1)
		{

			if (ch == '-')
			{
				if ((ch = in.read()) == '-')
				{
					if ((ch = in.read()) == '%')
					{
						if ((ch = in.read()) == '>')
							break;
						else
						{
							buf.append("--%");
							buf.append((char) ch);
						}
					}
					else
					{
						buf.append("--");
						buf.append((char) ch);
					}
				}
				else
				{
					buf.append('-');
					buf.append((char) ch);
				}
			}
			else
				buf.append((char) ch);
		}

		currentNode.addChild(parseCreateJspComment(buf.toString()));
		// currentNode.addChild (new JspComment (buf.toString ())) ;
	}

	/**
	 * Encounter a Process Instruction.
	 */
	protected void maybePI() throws IOException
	{
		// System.out.println ("maybePI") ;
		ch = in.read();
		while (ch != -1 && ch != '>')
			ch = in.read();
	}

	/**
	 * Encounter a Document DEclaration.
	 */
	protected void maybeDocDecl() throws IOException
	{
		// System.out.println ("maybeDocDecl") ;
		// if (ch == '[')
		StringBuffer buf = new StringBuffer();
		buf.append((char) ch);
		ch = in.read();
		while (ch != -1 && ch != '>')
		{
			buf.append((char) ch);
			ch = in.read();
		}

		currentNode.addChild(parseCreateXmlDeclNode(buf.toString()));
		// currentNode.addChild (new XmlDeclNode (buf.toString ())) ;
	}

	public boolean isNamingChar(int c)
	{
		return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z')
				|| (ch >= 'A' && ch <= 'Z') || ch == '_' || ch == '-'
				|| ch == ':';
	}

	/**
	 * A Attribute found.
	 */
	protected Attr maybeAttr() throws IOException
	{
		// System.out.println ("maybeAttr") ;

		Attr attr = new Attr();

		if (ch == -1)
			return null;
		peek();

		//
		while (ch != -1 && (!isNamingChar(ch)) &&ch!='=')
		{
			ch = in.read();
		}
		String name = "";

		while ((!isDelimiter(ch)) && (ch != '=') && (ch != -1))
		{
			if (isNamingChar(ch))
			{
				name += (char) ch;
				ch = in.read();
			}
			else
				break;
		}

		if (name.length() <= 0)
		{
			if(ch=='=')
				name="" ;//=的情况说明很变态 ='xxx'
			else
				return null;
		}

		if (ignoreCase)
			attr.setName(name.toLowerCase());
		else
			attr.setName(name);

		// System.out.println ("AttributeName: [" + attr.getName () + "]") ;
		peek();

		if (ch == -1)
			return attr;

		if (ch == '=') // value start
		{
			// attr.setValue(maybeAttrValue ()) ;
			Attr.parseAttrValue(attr, maybeAttrValue());
		}
		/*
		 * else { return maybeAttr () ; }
		 */
		return attr;
	}

	/**
	 * A Attribute value.
	 */
	protected String maybeAttrValue() throws IOException
	{

		ch = in.read();
		peek();
		String value = "";

		if (ch == '\'' || ch == '\"')
		{
			int term = ch;

			ch = in.read();
			while (ch != term && ch != -1)// && ch != '>')
			{
				// if (ch == '\"')
				// value += "&quot;" ;
				// else
				value += (char) ch;
				ch = in.read();
			}

			if (ch == term)
				ch = in.read();
		}
		else
		{
			value += (char) ch;
			ch = in.read();

			while (!isDelimiter(ch) && ch != -1 && ch != '>')
			{
				// Modify to support no qout value which contains '/'
				if (ch == '/')
				{
					ch = in.read();
					if (ch == '>')
					{
						in.unread('>');
						ch = '/';
						break;
					}
					value += '/';
				}
				value += (char) ch;
				ch = in.read();
			}

		}

		return value;

	}

	private void peek() throws IOException
	{

		StringBuffer buf1 = new StringBuffer();

		// ch = in.read () ;
		while (isDelimiter(ch))
		{
			// if (ch == '\n')
			// out.write (NL) ;
			buf1.append((char) ch);
			ch = in.read();
		}
		// When blanks in a tag, ignore.
		if (buf1.length() > 0 && (!isInELementDecl))
		{
			// System.out.println ("node:" + currentNode) ;
			if (currentNode == null)
				currentNode = root;

			currentNode.addChild(parseCreateXmlText(buf1.toString()));
			// currentNode.addChild (XmlText.parseToXmlText(buf1.toString())) ;
		}
	}

	protected boolean isDelimiter(int c)
	{
		return (c == ' ' || c == '\n' || c == '\r' || c == '\t');
	}

	/*
	 * 
	 * public boolean checkElement (String name) { String tmp = "|" + name + "|" ;
	 * if (tmp.indexOf (":") >= 0) return false ;
	 * 
	 * return NO_USED_ELEMENTS.indexOf (tmp) < 0 ; }
	 * 
	 * public boolean checkAttribute (String name , Attr attr) { String tmp =
	 * "|" + attr.getName () + "|" ; // System.out.println ("attr : " + tmp) ;
	 * return USED_ATTRIBUTES.indexOf (tmp) >= 0 ; }
	 * 
	 */
	/**
	 * Ignore this Element.
	 */
	protected void ignoreElement() throws IOException
	{
		while (ch != '>' && ch != -1)
			ch = in.read();
	}

	public void layout(Writer out) throws IOException
	{
		/*
		 * out.write (XML_HEAD + NL) ; out.write (XML_DOCTYPE + NL) ;
		 */
		out.write(root.toString());

		out.flush();
	}

	public void layout() throws IOException
	{
		layout(new OutputStreamWriter(System.out));
	}

	/*
	 * protected void finalize () throws Throwable { if (in != null) { in.close () ;
	 * in = null ; }
	 *  }
	 */
	public static void main(String argv[]) throws IOException
	{
		if (argv.length < 2)
		{
			System.err.println("Usage: XmlParser html xml");
			return;
		}

		NodeParser v = null;
		v = new NodeParser(argv[0]);
		try
		{

			v.parse();

		}
		catch (Throwable ioe)
		{
			ioe.printStackTrace();
		}

		System.out.println("done");
		v.layout(new OutputStreamWriter(new FileOutputStream(argv[1]), "GBK"));
	}

}